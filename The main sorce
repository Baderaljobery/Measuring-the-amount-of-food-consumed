

from __future__ import annotations

import warnings
warnings.filterwarnings("ignore")

from typing import Dict, Any, Optional, Tuple

import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture


class PrecisionFoodDetector:
    """
    Ù†Ø¸Ø§Ù… ØªÙ‚Ø¯ÙŠØ± Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø·Ø¹Ø§Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø­Ø§Ø³ÙˆØ¨ÙŠØ© Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ© (Ø¨Ø¯ÙˆÙ† Ø´Ø¨ÙƒØ§Øª Ø¹Ù…ÙŠÙ‚Ø©).

    Ø§Ù„Ù…Ø±Ø§Ø­Ù„:
      1) Preprocessing: Bilateral + CLAHE(LAB)
      2) Plate/Container mask: Edges/Contours (+ fallback)
      3) Segmentation: Gaussian Mixture (GMM) Ø¹Ù„Ù‰ Ù…ÙŠØ²Ø§Øª Ù„ÙˆÙ†ÙŠØ© + Ù…ÙƒØ§Ù†ÙŠØ©
      4) Refinement: Ø¹Ù…Ù„ÙŠØ§Øª Ù…ÙˆØ±ÙÙˆÙ„ÙˆØ¬ÙŠØ© + Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…ÙƒÙˆÙ‘Ù†Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø©
      5) Ù‚ÙŠØ§Ø³ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø«Ù… Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‘ÙØ³ÙØ¨ Ù‚Ø¨Ù„/Ø¨Ø¹Ø¯

    Parameters
    ----------
    debug_mode : bool
        Ù„Ø·Ø¨Ø§Ø¹Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙ†ÙÙŠØ°.
    """

    def __init__(self, debug_mode: bool = True) -> None:
        self.debug_mode = debug_mode

    # ---------------------------------------------------------------------
    # 1) Loading & Preprocessing
    # ---------------------------------------------------------------------
    def load_and_preprocess(self, image_path: str) -> np.ndarray:
        """
        ÙŠØ­Ù…Ù‘Ù„ ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø± ÙˆÙŠØ­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ RGB Ù…Ø¹ ØªØµØºÙŠØ± Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ù„ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©.

        Returns
        -------
        img_rgb : np.ndarray
            ØµÙˆØ±Ø© RGB Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©.
        """
        img = cv2.imread(image_path)
        if img is None:
            raise ValueError(f"Cannot load image: {image_path}")

        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        h, w = img_rgb.shape[:2]
        if w > 800:
            scale = 800 / w
            img_rgb = cv2.resize(img_rgb, (int(w * scale), int(h * scale)), interpolation=cv2.INTER_AREA)

        return img_rgb

    def advanced_preprocessing(self, img_rgb: np.ndarray) -> np.ndarray:
        """
        ØªØ­Ø³ÙŠÙ†Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©: Bilateral Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¶Ø¬ÙŠØ¬ Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø­ÙˆØ§ÙØŒ
        Ùˆ CLAHE Ø¹Ù„Ù‰ Ù‚Ù†Ø§Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© ÙÙŠ LAB Ù„ØªØ¹Ø²ÙŠØ² Ø§Ù„ØªØ¨Ø§ÙŠÙ†.
        """
        img_float = img_rgb.astype(np.float32) / 255.0

        
        filtered_u8 = cv2.bilateralFilter((img_float * 255).astype(np.uint8), d=9, sigmaColor=75, sigmaSpace=75)

        
        lab = cv2.cvtColor(filtered_u8, cv2.COLOR_RGB2LAB)
        clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
        lab[:, :, 0] = clahe.apply(lab[:, :, 0])

        enhanced = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)
        return enhanced

      
    def detect_container_boundary(self, img_rgb: np.ndarray) -> np.ndarray:
        """
        ÙŠÙƒØªØ´Ù Ù‚Ù†Ø§Ø¹ Ø§Ù„ÙˆØ¹Ø§Ø¡/Ø§Ù„Ø·Ø¨Ù‚ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­ÙˆØ§Ù Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³ + Ø£ÙƒØ¨Ø± ÙƒÙ†ØªÙˆØ±.
        ÙÙŠ Ø­Ø§Ù„ Ø§Ù„ÙØ´Ù„ØŒ ÙŠØ³ØªØ®Ø¯Ù… Ø¥Ù‡Ù„ÙŠÙ„Ø¬ Ù…Ø±ÙƒØ²ÙŠ ÙƒØ®Ø·Ø© Ø¨Ø¯ÙŠÙ„Ø©.
        """
        gray = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2GRAY)

        edges_fine = cv2.Canny(gray, 50, 150, apertureSize=3)
        edges_coarse = cv2.Canny(gray, 30, 100, apertureSize=5)
        edges = cv2.bitwise_or(edges_fine, edges_coarse)

        edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)))

        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        h, w = gray.shape[:2]
        mask = np.zeros((h, w), dtype=np.uint8)

        if contours:
            largest = max(contours, key=cv2.contourArea)
            cv2.fillPoly(mask, [largest], 255)
            
            mask = cv2.erode(mask, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15)), iterations=1)
            return mask

        
        cv2.ellipse(mask, (w // 2, h // 2), (w // 3, h // 3), 0, 0, 360, 255, -1)
        return mask


    def gaussian_mixture_segmentation(self, img_rgb: np.ndarray, container_mask: np.ndarray) -> np.ndarray:
        """
        ÙŠØ·Ø¨Ù‘Ù‚ GMM Ø¹Ù„Ù‰ Ù…ÙŠØ²Ø§Øª Ù„ÙˆÙ†ÙŠØ© (RGB/HSV/LAB) + Ù…ÙƒØ§Ù†ÙŠØ© (x/w, y/h) Ø¯Ø§Ø®Ù„ Ù‚Ù†Ø§Ø¹ Ø§Ù„ÙˆØ¹Ø§Ø¡
        Ø«Ù… ÙŠØ­Ø¯Ù‘Ø¯ Ø£ÙŠ Ø§Ù„Ø¹Ù†Ø§Ù‚ÙŠØ¯ ØªÙ…Ø«Ù‘Ù„ "Ø·Ø¹Ø§Ù…" Ø¹Ø¨Ø± Ù‚ÙˆØ§Ø¹Ø¯ ØªØ­Ù„ÙŠÙ„ Ù…Ø¨Ø³Ù‘Ø·Ø©.
        """
        h, w = img_rgb.shape[:2]
        if container_mask is None or cv2.countNonZero(container_mask) == 0:
            return np.zeros((h, w), dtype=np.uint8)

        
        hsv = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2HSV)
        lab = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2LAB)

        ys, xs = np.where(container_mask > 0)
        if len(xs) == 0:
            return np.zeros((h, w), dtype=np.uint8)

        
        rgb_feats = img_rgb[ys, xs].astype(np.float32) / 255.0
        hsv_feats = hsv[ys, xs].astype(np.float32) / np.array([180.0, 255.0, 255.0], dtype=np.float32)
        lab_feats = lab[ys, xs].astype(np.float32) / np.array([100.0, 255.0, 255.0], dtype=np.float32)
        spatial = np.stack([xs / float(w), ys / float(h)], axis=1).astype(np.float32)

        features = np.concatenate([rgb_feats, hsv_feats, lab_feats, spatial], axis=1)

        
        n_components = int(min(8, max(2, features.shape[0] // 100 + 2)))
        gmm = GaussianMixture(n_components=n_components, covariance_type="full", random_state=42)
        labels = gmm.fit_predict(features)

        
         food_mask = np.zeros((h, w), dtype=np.uint8)

        for cid in range(n_components):
            cluster_idx = (labels == cid)
            if not np.any(cluster_idx):
                continue

            cluster_feats = features[cluster_idx]                 # (N_c, F)
            cluster_pos = np.stack([ys[cluster_idx], xs[cluster_idx]], axis=1)  # (N_c, 2)

            
            if self.analyze_cluster_for_food(cluster_feats):
                food_mask[cluster_pos[:, 0], cluster_pos[:, 1]] = 255

        return food_mask

    def analyze_cluster_for_food(self, cluster_features: np.ndarray) -> bool:
        """
        Ù‚ÙˆØ§Ø¹Ø¯ Ù‚Ø±Ø§Ø± Ù…Ø¨Ø³Ù‘Ø·Ø© Ù„Ù„ØªÙ…ÙŠÙŠØ² Ø¨ÙŠÙ† "Ø·Ø¹Ø§Ù…" Ùˆ"Ø·Ø¨Ù‚/Ø§Ù†Ø¹ÙƒØ§Ø³":
          - ØªØ´Ø¨Ø¹ Ù…ØªÙˆØ³Ø· Ù…Ø¹Ù‚ÙˆÙ„ (Ù„ÙŠØ³ Ø±Ù…Ø§Ø¯ÙŠÙ‹Ø§ ØªÙ…Ø§Ù…Ù‹Ø§)
          - Ù‚ÙŠÙ…Ø© Ø¥Ø¶Ø§Ø¡Ø© Ù„ÙŠØ³Øª Ù…Ù†Ø®ÙØ¶Ø© Ø¬Ø¯Ù‹Ø§ ÙˆÙ„Ø§ Ù…Ø±ØªÙØ¹Ø© Ø¬Ø¯Ù‹Ø§
          - ØªØ¨Ø§ÙŠÙ† Ù„ÙˆÙ†ÙŠ Ù…Ù„Ø­ÙˆØ¸ (Texture)
          - Ø­Ø¬Ù… Ø¹Ù†Ù‚ÙˆØ¯ Ù…Ø¹Ù‚ÙˆÙ„ (ÙŠØªØ­Ù…Ù‘Ù„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)
        """
        if cluster_features.size == 0:
            return False


        rgb = (cluster_features[:, 0:3] * 255.0)
        hsv = (cluster_features[:, 3:6] * np.array([180.0, 255.0, 255.0], dtype=np.float32))

        mean_sat = float(np.mean(hsv[:, 1]))
        mean_val = float(np.mean(hsv[:, 2]))
        mean_rgb_std = float(np.mean(np.std(rgb, axis=0)))

       
        cluster_size_ok = (len(cluster_features) >= 200)

        is_food = (
            mean_sat > 25 and          
            20 < mean_val < 220 and    
            mean_rgb_std > 5 and       
            cluster_size_ok
        )
        return is_food


    def refine_with_morphology(self, mask: np.ndarray, reference_img: np.ndarray) -> np.ndarray:
        """
        ØªÙ†Ù‚ÙŠØ© Ø§Ù„Ù‚Ù†Ø§Ø¹: ÙØªØ­ Ù„Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡ØŒ Ø¥ØºÙ„Ø§Ù‚ Ù„Ù…Ù„Ø¡ Ø§Ù„ÙØ¬ÙˆØ§ØªØŒ
        Ø«Ù… Ø­Ø°Ù Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© (â‰¥ 0.1% Ù…Ù† Ù…Ø³Ø§Ø­Ø© Ø§Ù„ØµÙˆØ±Ø©).
        """
        if mask is None or mask.size == 0:
            return mask

        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)))
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7)))

        num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(mask)
        total_pixels = reference_img.shape[0] * reference_img.shape[1]
        min_area = max(1, int(total_pixels * 0.001))  # 0.1% Ù…Ù† Ù…Ø³Ø§Ø­Ø© Ø§Ù„ØµÙˆØ±Ø©

        refined = np.zeros_like(mask)
        for i in range(1, num_labels):  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø®Ù„ÙÙŠØ©
            if stats[i, cv2.CC_STAT_AREA] >= min_area:
                refined[labels == i] = 255

        return refined


    def detect_food_in_image(self, image_path: str) -> Optional[Dict[str, Any]]:
        """
        ÙŠÙØ´ØºÙ‘Ù„ ÙƒØ§Ù…Ù„ Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙˆØ§Ø­Ø¯Ø© ÙˆÙŠØ¹ÙŠØ¯ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ÙˆØ³ÙŠØ·Ø© ÙˆØ§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©.
        """
        try:
            img = self.load_and_preprocess(image_path)
            enhanced = self.advanced_preprocessing(img)

            if self.debug_mode:
                print(f"âœ“ Loaded image: {img.shape}")

            container_mask = self.detect_container_boundary(enhanced)
            if self.debug_mode:
                print(f"âœ“ Container detected: {int(np.sum(container_mask > 0))} pixels")

            food_mask_raw = self.gaussian_mixture_segmentation(enhanced, container_mask)
            if self.debug_mode:
                print(f"âœ“ Initial food detection: {int(np.sum(food_mask_raw > 0))} pixels")

            food_mask = self.refine_with_morphology(food_mask_raw, img)
            food_area = int(np.sum(food_mask > 0))

            if self.debug_mode:
                print(f"âœ“ Final food area: {food_area} pixels")

            return {
                "original_image": img,
                "enhanced_image": enhanced,
                "container_mask": container_mask,
                "food_mask": food_mask,
                "food_area": food_area,
            }

        except Exception as e:
            print(f"âŒ Error processing {image_path}: {e}")
            return None


    def calculate_consumption(self, before_path: str, after_path: str) -> Optional[Dict[str, Any]]:
        """
        ÙŠØ­Ø³Ø¨ Ù†Ø³Ø¨ Ø§Ù„Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ/Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¨ÙŠÙ† ØµÙˆØ±ØªÙŠÙ† (Ù‚Ø¨Ù„/Ø¨Ø¹Ø¯).
        """
        print("ğŸ” PRECISION FOOD DETECTION SYSTEM")
        print("=" * 50)

        print("\nğŸ“· Processing BEFORE image...")
        before = self.detect_food_in_image(before_path)
        if before is None:
            print("âŒ Failed to process BEFORE image")
            return None

        print("\nğŸ“· Processing AFTER image...")
        after = self.detect_food_in_image(after_path)
        if after is None:
            print("âŒ Failed to process AFTER image")
            return None

        before_area = before["food_area"]
        after_area = after["food_area"]

        if before_area > 0:
            consumed_pct = ((before_area - after_area) / before_area) * 100.0
            remaining_pct = (after_area / before_area) * 100.0
        else:
            consumed_pct = 0.0
            remaining_pct = 0.0

 
        consumed_pct = float(np.clip(consumed_pct, 0.0, 100.0))
        remaining_pct = float(np.clip(remaining_pct, 0.0, 100.0))

        return {
            "consumed_percentage": consumed_pct,
            "remaining_percentage": remaining_pct,
            "before_area": int(before_area),
            "after_area": int(after_area),
            "before_result": before,
            "after_result": after,
        }


    def visualize_results(self, results: Dict[str, Any]) -> None:
        """
        ÙŠØ¹Ø±Ø¶ Ø´Ø¨ÙƒØ© ØµÙˆØ± ØªÙˆØ¶Ù‘Ø­: Ø§Ù„Ø£ØµÙ„ÙŠØ© ÙˆØ§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©ØŒ Ù‚Ù†Ø§Ø¹ Ø§Ù„ÙˆØ¹Ø§Ø¡ØŒ Ù‚Ù†Ø§Ø¹ Ø§Ù„Ø·Ø¹Ø§Ù…ØŒ
        ÙˆØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ø·Ø¹Ø§Ù…ØŒ ÙˆØ®Ø±ÙŠØ·Ø© Ø§Ù„ÙØ±Ù‚ØŒ ÙˆÙ„ÙˆØ­Ø© ØªÙ„Ø®Øµ Ø§Ù„Ù†Ù‘ÙØ³ÙØ¨.
        """
        fig, axes = plt.subplots(3, 4, figsize=(20, 15))

        before = results["before_result"]
        after = results["after_result"]


        axes[0, 0].imshow(before["original_image"]); axes[0, 0].set_title("Before - Original", fontweight="bold"); axes[0, 0].axis("off")
        axes[0, 1].imshow(before["enhanced_image"]); axes[0, 1].set_title("Before - Enhanced", fontweight="bold"); axes[0, 1].axis("off")
        axes[0, 2].imshow(after["original_image"]);  axes[0, 2].set_title("After - Original",  fontweight="bold"); axes[0, 2].axis("off")
        axes[0, 3].imshow(after["enhanced_image"]);  axes[0, 3].set_title("After - Enhanced",  fontweight="bold"); axes[0, 3].axis("off")


        axes[1, 0].imshow(before["container_mask"], cmap="gray"); axes[1, 0].set_title("Before - Container", fontweight="bold"); axes[1, 0].axis("off")
        axes[1, 1].imshow(before["food_mask"], cmap="gray");      axes[1, 1].set_title("Before - Food Detection", fontweight="bold"); axes[1, 1].axis("off")
        axes[1, 2].imshow(after["container_mask"], cmap="gray");  axes[1, 2].set_title("After - Container",  fontweight="bold"); axes[1, 2].axis("off")
        axes[1, 3].imshow(after["food_mask"], cmap="gray");       axes[1, 3].set_title("After - Food Detection",  fontweight="bold"); axes[1, 3].axis("off")


        overlay_b = before["original_image"].copy()
        overlay_b[before["food_mask"] == 0] = overlay_b[before["food_mask"] == 0] // 2
        axes[2, 0].imshow(overlay_b); axes[2, 0].set_title("Before - Food Highlighted", fontweight="bold"); axes[2, 0].axis("off")

        overlay_a = after["original_image"].copy()
        overlay_a[after["food_mask"] == 0] = overlay_a[after["food_mask"] == 0] // 2
        axes[2, 1].imshow(overlay_a); axes[2, 1].set_title("After - Remaining Food", fontweight="bold"); axes[2, 1].axis("off")

        if before["food_mask"].shape == after["food_mask"].shape:
            diff = cv2.absdiff(before["food_mask"], after["food_mask"])
            axes[2, 2].imshow(diff, cmap="Reds"); axes[2, 2].set_title("Consumed Areas", fontweight="bold"); axes[2, 2].axis("off")
        else:
            axes[2, 2].text(0.5, 0.5, "Different sizes", ha="center", va="center"); axes[2, 2].axis("off")

        axes[2, 3].text(0.1, 0.8, "ğŸ½ï¸ CONSUMED", fontsize=16, fontweight="bold", transform=axes[2, 3].transAxes)
        axes[2, 3].text(0.1, 0.65, f"{results['consumed_percentage']:.1f}%", fontsize=28, color="red", fontweight="bold", transform=axes[2, 3].transAxes)
        axes[2, 3].text(0.1, 0.4, "ğŸ“¦ REMAINING", fontsize=16, fontweight="bold", transform=axes[2, 3].transAxes)
        axes[2, 3].text(0.1, 0.25, f"{results['remaining_percentage']:.1f}%", fontsize=28, color="green", fontweight="bold", transform=axes[2, 3].transAxes)
        axes[2, 3].axis("off")

        plt.suptitle("ğŸ¯ PRECISION FOOD DETECTION RESULTS", fontsize=18, fontweight="bold")
        plt.tight_layout()
        plt.show()



def precision_food_analysis(before_image: str, after_image: str) -> Optional[float]:
    """
    ÙˆØ§Ø¬Ù‡Ø© Ø³Ø±ÙŠØ¹Ø©: ÙŠØ´ØºÙ‘Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…Ù„ ÙˆÙŠØ¹ÙŠØ¯ Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø³ØªÙ‡Ù„Ùƒ.
    """
    detector = PrecisionFoodDetector(debug_mode=True)
    print("ğŸš€ Starting PRECISION FOOD DETECTION")
    print("ğŸ”¬ Using: Gaussian Mixture Model + Advanced Computer Vision")

    results = detector.calculate_consumption(before_image, after_image)
    if results:
        detector.visualize_results(results)
        return results["consumed_percentage"]

    print("âŒ Analysis failed")
    return None


def test_single_image(image_path: str) -> Optional[Dict[str, Any]]:
    """
    Ø§Ø®ØªØ¨Ø§Ø± Ø³Ø±ÙŠØ¹ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ÙˆØ§Ø­Ø¯Ø©: ÙŠØ¹Ø±Ø¶ Ø§Ù„Ù‚Ù†Ø§Ø¹ ÙˆØ§Ù„Ù…Ø³Ø§Ø­Ø©.
    """
    detector = PrecisionFoodDetector(debug_mode=True)
    result = detector.detect_food_in_image(image_path)

    if result:
        plt.figure(figsize=(15, 5))
        plt.subplot(1, 3, 1); plt.imshow(result["original_image"]); plt.title("Original"); plt.axis("off")
        plt.subplot(1, 3, 2); plt.imshow(result["food_mask"], cmap="gray"); plt.title("Food Mask (White=Food)"); plt.axis("off")
        overlay = result["original_image"].copy()
        overlay[result["food_mask"] == 0] = [255, 0, 0]
        plt.subplot(1, 3, 3); plt.imshow(cv2.addWeighted(result["original_image"], 0.7, overlay, 0.3, 0))
        plt.title("Food Highlighted"); plt.axis("off")
        plt.suptitle(f'Food Area: {result["food_area"]:,} pixels')
        plt.show()
        return result
    return None


if __name__ == "__main__":
    # Ù…Ø«Ø§Ù„: Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø­Ø³Ø¨ ØµÙˆØ±Ùƒ
    before_path = "/content/6befor.jpg"
    after_path  = "/content/6-2after.jpg"

    print("ğŸ¯ PRECISION FOOD DETECTOR")
    print("ğŸ”¬ Advanced Computer Vision System")
    print("-" * 40)

    
    # test_single_image(before_path)

   
    consumption = precision_food_analysis(before_path, after_path)
    if consumption is not None:
        print(f"\nâœ… FINAL RESULT: {consumption:.1f}% of food consumed")
        print("ğŸ¯ High precision analysis complete!")
    else:
        print("\nâŒ Could not complete analysis")
